

#' @title generates sequence of variable spanning from min to max
#' @description similar to modelr::seq_range but can handle categorical variables
#' @param data_ls data_ls object generated by f_clean_data(), or a named list
#'   list( data = <dataframe>, numericals = < vector with column names of
#'   numerical columns>)
#' @param col_var character vector denoting variable
#' @param n integer number of intermediate data points, Default: 500
#' @return vector
#' @examples
#' data_ls = f_clean_data(mtcars)
#' col_var = 'disp'
#' f_model_seq_range( data_ls, col_var, 10)
#' @rdname f_model_seq_range
#' @export
f_model_seq_range = function( data_ls, col_var, n = 500 ){

  vec = data_ls$data[[col_var]]

  if(col_var %in% data_ls$numericals){
    sequence = seq( min(vec), max(vec), length.out = n)
  }else{
    # we need to maintain the variable type (unordered vs ordered)
    # this approach is messy but a bit safer then extracting levels
    # as character and then converting back to the original data_type
    sequence = tibble( levels = vec ) %>%
      group_by(levels) %>%
      mutate( rwn = 1
              , rwn = cumsum(rwn) ) %>%
      filter( rwn == 1 ) %>%
      arrange(levels) %>%
      .$levels
  }

  return(sequence)
}

#' @title generates a data grid based on a formula
#' @description the range of one specified variable is expanded, while all other
#'   variables are set to the most common values. Similar to modelr::data_grid
#'   but it can deal with factors.
#' @param data_ls data_ls object generated by f_clean_data(), or a named list
#'   list( data = <dataframe>, numericals = < vector with column names of
#'   numerical columns>)
#' @param formula formula
#' @return dataframe
#' @examples
#' data_ls = f_clean_data(mtcars)
#' formula = disp~cyl+mpg+hp
#' f_model_data_grid( 'mpg', data_ls, formula,  10 )
#' @rdname f_model_data_grid
#' @export
f_model_data_grid = function( col_var, data_ls, formula, n = 500 ){

  vars         = f_manip_get_variables_from_formula(formula)

  response_var_sym = as.name(col_var)

  if( ! col_var %in% vars ){
    stop('f_model_data_grid supplied variable is not in formula')
  }

  summarized_ls = f_manip_summarize_2_median_and_most_common_factor(data_ls)

  range = f_model_seq_range( data_ls, col_var, n )

  grid = summarized_ls$data %>%
    select( one_of(vars) )%>%
    mutate( !!response_var_sym := list( response_var_sym = range ) ) %>%
    unnest( !!response_var_sym , .drop = F) %>%
    select( one_of(col_var), everything() )

  return(grid)

}

#' @title add predictions to grid (regression models)
#' @description wrapper for modelr::add_predictions
#' @param grid grid containing all variables used for the model
#' @param m model
#' @param var character vector denoting response variable
#' @return grid
#' @examples
#' data_ls = f_clean_data(mtcars)
#' formula = disp~hp+mpg
#' m = lm(formula, data_ls$data)
#' grid = f_model_data_grid(data_ls, formula, 'hp', 10) %>%
#'   f_model_add_predictions_2_grid_regression( m, 'disp')
#' @seealso
#'  \code{\link[modelr]{add_predictions}}
#' @rdname f_model_add_predictions_2_grid_regression
#' @export
#' @importFrom modelr add_predictions
f_model_add_predictions_2_grid_regression = function( grid, m, var){

  grid = grid %>%
    modelr::add_predictions( m, var)

  return(grid)

}



#' @title plot model dependency on most important variables
#' @description response variable will be plotted against the entire range of
#'   each variable staring with the most important ones. All other variables
#'   will be set to median or most common factor. This function requires a ranked list
#'   of the most important variables as returned by f_model_importance()
#' @param m a regression model
#' @param ranked_variables datafram as returned by f_model_importance()
#' @param title character vector as plot title, Default:
#'   unlist(stringr::str_split(class(m)[1], "\\."))[1]
#' @param data a dataframe, only necessary if it differs from data_ls$data, Default: NULL
#' @param formula the formula used to train the model
#' @param data_ls data_ls object generated by f_clean_data(), or a named list
#'   list( data = <dataframe>, numericals = < vector with column names of
#'   numerical columns>)
#' @param variable_color_code dataframe created by f_plot_color_code_variables()
#' @param limit integer limit the number of variables to be plotted, Default: 10
#' @param ... arguments passed to facet_wrap e.g. usefull for nrow, ncol
#' @return plot
#' @examples
#'
#' # regular version--------------------------------------
#' data_ls             = f_clean_data(mtcars)
#' data                = data_ls$data
#' formula             = disp~hp+mpg+cyl
#' m                   = randomForest::randomForest(formula, data)
#' ranked_variables    = f_model_importance( m, data)
#' variable_color_code = f_plot_color_code_variables(data_ls)
#' limit               = 10
#' f_model_plot_variable_dependency_regression( m
#'                                              , ranked_variables
#'                                              , title = unlist( stringr::str_split( class(m)[1], '\\.') )[1]
#'                                              , data
#'                                              , formula
#'                                              , data_ls
#'                                              , variable_color_code
#'                                              , limit
#'                                              )
#'
#' #pipe version ------------------------------------------
#'
#' data_ls = f_clean_data(mtcars)
#' form = as.formula('disp~hp+cyl+wt')
#' variable_color_code = f_plot_color_code_variables(data_ls)
#' limit            = 10
#'
#'  pl = pipelearner::pipelearner( data_ls$data ) %>%
#'   pipelearner::learn_models( rpart::rpart, form ) %>%
#'   pipelearner::learn_models( randomForest::randomForest, form ) %>%
#'   pipelearner::learn_models( e1071::svm, form ) %>%
#'   pipelearner::learn() %>%
#'   mutate( imp   = map2(fit, train, f_model_importance)
#'           ,plot = pmap( list( m = fit, ranked_variables = imp, title = model, data = train)
#'                         , .f = f_model_plot_variable_dependency_regression
#'                         , formula = form
#'                         , data_ls = data_ls
#'                         , variable_color_code = variable_color_code
#'                        , limit = limit
#'          )
#'   )
#'
#' @seealso \code{\link[stringr]{str_split}}
#' @rdname f_model_plot_variable_dependency_regression
#' @export
#' @importFrom stringr str_split
f_model_plot_variable_dependency_regression = function( m
                                                       , ranked_variables
                                                       , title = unlist( stringr::str_split( class(m)[1], '\\.') )[1]
                                                       , data = NULL
                                                       , formula
                                                       , data_ls
                                                       , variable_color_code = f_plot_color_code_variables(data_ls)
                                                       , limit = 10
                                                       , log_y = F
                                                       , ...
                                                      ){

  # modelling data might have been filtered therefore we will replace data
  # data_ls

  if( !is.null(data) ){
    data_ls$data = as.data.frame(data)
  }

  response_var = f_manip_get_response_variable_from_formula( formula )
  vars         = f_manip_get_variables_from_formula( formula )

  #plot function

  vars_and_col = ranked_variables %>%
    rename( variables = row_names ) %>%
    arrange_( 'rank' ) %>%
    filter( variables %in% vars ) %>%
    head( limit ) %>%
    left_join( variable_color_code ) %>%
    arrange( variables )

  col_vector = vars_and_col[['color']]

  grid = vars_and_col %>%
    mutate( grid = map( variables
                        , f_model_data_grid
                        , data_ls
                        , formula)
            ,grid = map( grid, f_model_add_predictions_2_grid_regression, m, response_var)
            ) %>%
    unnest(grid, .drop = F) %>%
    mutate_if( is.factor, f_manip_factor_2_numeric ) %>%
    mutate( rwn = 1:nrow(.)
            , x = map2(variables, rwn, function(var,rwn,data) data[[var]][rwn], .)
            , x = unlist(x)
            #, variables = forcats::fct_reorder(variables, desc(value) )
            )

  if( log_y ){

    grid[, response_var][ grid[, response_var] <= 0] = 0.01
    grid[, response_var] = log( grid[, response_var] )

  }

  p = ggplot( grid, aes_string( 'x', response_var, color = 'variables') ) +
      geom_line( size = 2) +
      facet_wrap(~variables
                 , scales = 'free_x'
                 , ... ) +
      theme( legend.position = 'None') +
      labs( x = ''
            , y = response_var
            , title = title
            ) +
      scale_color_manual( name = 'variables', values = vars_and_col$color , limits = levels(grid$variables) )

    return(p)

}
