



#' @title calculates maximum difference in group means and medians
#' @description used as a helper function for f_stat_anova
#' @param df dataframe
#' @param col_group character vector denoting grouping variable
#' @param col_variable character vector denoting variable
#' @return dataframe
#' @examples
#' set.seed(1)
#' df = tibble( fct = sample(LETTERS[1:5], 100, replace = T)
#'              , v1  = 1
#'              , v2  = rnorm(100, 4)
#'              , v3  = c( rep(3, 50), rep(8,50) )
#' )
#'
#' col_group = 'fct'
#'
#' f_stat_diff_of_means_medians(df, col_group, 'v1') %>%
#'   bind_rows( f_stat_diff_of_means_medians(df, col_group, 'v2') ) %>%
#'   bind_rows( f_stat_diff_of_means_medians(df, col_group, 'v3') )
#' @rdname f_stat_diff_of_means_medians
#' @export
f_stat_diff_of_means_medians = function(df, col_group, col_variable){


  data = df %>%
    select( group = one_of(col_group), variable = one_of(col_variable) )%>%
    mutate ( variable = f_manip_bring_to_pos_range(variable) ) %>%
    group_by( group ) %>%
    summarise( means     = mean(variable,   na.rm = T)
               , medians = median(variable, na.rm = T) ) %>%
    ungroup() %>%
    summarise( variable               = col_variable
               , diff_of_means        = max(means) - min(means)
               , diff_of_means_perc   = ( ( max(means) - min(means) ) /max(means) ) *100
               , diff_of_medians      = max(medians) - min(medians)
               , diff_of_medians_perc = ( ( max(medians) - min(medians) ) /max(means) ) *100    )


  return(data)
}

#' @title generate a datatframe with anova results from a data_ls list
#' @description returns a dataframe with shapiro, anova und kruskal p values
#'   supplemented with maximum difference of means and medians between groups
#'@param data_ls data_ls object generated by f_clean_data(), or a named list
#'  list( data = <dataframe>, numericals = < vector with column names of
#'  numerical columns>)
#' @param col_group character vector denoting grouping variable
#' @param boxcox perform analysis on boxcox-transformed or numerical variables
#' @return dataframe
#' @examples
#' df_anova = data_ls = f_clean_data(mtcars) %>%
#'   f_stat_anova('cyl')
#'
#' df_anova
#' @seealso \code{\link[stringr]{str_c}}
#' \code{\link[purrr]{map}},\code{\link[purrr]{map_dbl}}
#' \code{\link{f_stat_anova}}
#' @rdname f_anova_stats
#' @export
#' @importFrom stringr str_c
#' @importFrom purrr map map_dbl
f_stat_anova = function(data_ls, col_group, boxcox = F) {

  if( ! col_group %in% data_ls$categoricals ){
    stop('grouping variable not in categoricals')
  }

  if( boxcox == T & ! is.null(data_ls$boxcox) ){

    variables = data_ls$boxcox_names
    data = data_ls$boxcox_data

  }else{
    variables = data_ls$numericals
    data = data_ls$data

  }

  formula = stringr::str_c('value~',col_group) %>%
    as.formula()

  df_anova = data %>%
    as_tibble() %>%
    select( one_of( c(col_group, variables) ) ) %>%
    gather(key = 'variable', value = 'value', one_of( variables ) ) %>%
    group_by( variable ) %>%
    filter( sd(value) != 0 ) %>%
    nest( one_of(col_group), value) %>%
    mutate( model_anova     = purrr::map( data, ~aov( formula, data = .))
            , summary_anova = purrr::map( model_anova, summary)
            , summary_anova = purrr::map( summary_anova
                                          , function(x) x[[1]])
            , anova_pval    = purrr::map(summary_anova, 'Pr(>F)')
            , anova_pval    = purrr::map_dbl(anova_pval
                                             , function(x) x[1])
            , model_kruskal = purrr::map( data, ~kruskal.test(formula, data = .) )
            , kruskal_pval  = purrr::map_dbl(model_kruskal, 'p.value')
            , model_shapiro = purrr::map(data
                                         , function(x) shapiro.test(sample(x$value, 5000, replace = T) ) )
            , shapiro_stat  = purrr::map_dbl(model_shapiro,'statistic')
            , shapiro_pval  = purrr::map_dbl(model_shapiro,'p.value')
            , diff_df       = purrr::map( data, f_stat_diff_of_means_medians, col_group = col_group, col_variable = 'value') ) %>%
    unnest(diff_df) %>%
    select(variable
           , shapiro_stat
           , shapiro_pval
           , anova_pval
           , kruskal_pval
           , diff_of_means
           , diff_of_means_perc
           , diff_of_medians
           , diff_of_medians_perc
    )

  return(df_anova)
}


#' @title calculate the maximal difference in frequencies between to categorical variables
#' @description used as a helper function for f_stat_chi_square
#' @param df dataframe containing both avariables
#' @param col_var1 character vector denoting variable column 1
#' @param col_var2 character vector denoting variable column 2
#' @return dataframe
#' @examples
#' data_ls = f_clean_data(mtcars)
#' df_chi_squ = f_stat_max_diff_of_freq(data_ls$data, 'cyl', 'gear')
#' @rdname f_stat_max_diff_of_freq
#' @export
f_stat_max_diff_of_freq = function(df, col_var1, col_var2){

  t = table( df[[col_var1]], df[[col_var2]] ) %>%
    as_tibble() %>%
    group_by( Var1 ) %>% #Var1 and Var2 are the automatically assigneed column names
    mutate ( diff_var1          = ( max(n)-min(n) )
             , diff_var1_perc = ( ( max(n)-min(n))/ max(n) *100)
    ) %>%
    group_by( Var2 ) %>%
    mutate ( diff_var2          = ( max(n)-min(n) )
             , diff_var2_perc = ( ( max(n)-min(n))/ max(n) *100)
    ) %>%
    ungroup()%>%
    summarise( max_diff_freq          = max( c(diff_var1, diff_var2) )
               , max_diff_freq_perc  = max( c(diff_var1_perc, diff_var2_perc) )
    )
}


#' @title generate a datatframe with anova results from a data_ls list
#' @description FUNCTION_DESCRIPTION
#'@param data_ls data_ls object generated by f_clean_data(), or a named list
#'  list( data = <dataframe>, numericals = < vector with column names of
#'  numerical columns>)
#' @param col_group character vector denoting grouping variable
#' @return OUTPUT_DESCRIPTION
#' @examples
#' \dontrun{
#' data_ls = f_clean_data(mtcars)
#' df_chi_squ = f_stat_chi_square(data_ls, 'cyl')
#' df_chi_squ
#' @seealso
#'  \code{\link[purrr]{is_empty}},\code{\link[purrr]{map}},\code{\link[purrr]{map_dbl}}
#' @rdname f_stat_chi_square
#' @export
#' @importFrom purrr is_empty map map_dbl
f_stat_chi_square = function(data_ls, col_group) {

  if( ! col_group %in% data_ls$categoricals ){
    stop('grouping variable not in categoricals')
  }

  data = data_ls$data

  variables = data_ls$categoricals[!data_ls$categoricals == col_group]

  if(purrr::is_empty(variables)) return()

  df_chi = data %>%
    as_tibble() %>%
    select( one_of( c(col_group, variables) ) ) %>%
    gather(key = 'variable', value = 'value', one_of( variables  ) ) %>%
    group_by( variable ) %>%
    nest( one_of( col_group ), value) %>%
    mutate(  model_chi = purrr::map( data, ~chisq.test(x = .[[col_group]]
                                                       , y = .[['value']]
    ) )
    ,chi_pval  = purrr::map_dbl(model_chi, 'p.value')
    ,diff_df   = purrr::map(data, f_stat_max_diff_of_freq, col_group, 'value')  ) %>%
    unnest(diff_df) %>%
    select(variable, chi_pval, max_diff_freq, max_diff_freq_perc)

  return(df_chi)
}

f_stat_combine_anova_with_chi_square = function(df_anova, df_chi_square){

  df_comb = df_anova %>%
    mutate( final_p_value = ifelse(shapiro_stat >= 0.9 & shapiro_pval <= 0.05
                                   , anova_pval, kruskal_pval) ) %>%
    select(variable, p_value = final_p_value , diff_perc = diff_of_means_perc) %>%
    bind_rows( select(df_chi_squ, variable, p_value = chi_pval, diff_perc = max_diff_freq_perc) )%>%
    arrange(p_value)


}

f_stat_group_ana_taglist = function(data_ls, col_group, tresh_p_val = 0.05, thresh_diff_perc = 3, grouping_key = NULL){

  df_anova = f_stat_anova( data_ls, col_group )
  df_chi   = f_stat_chi_square( data_ls, col_group )
  df_comb  = f_stat_combine_anova_with_chi_square( df_anova, df_chi_squ )



  f_plot = function( var, title, col_group, data_ls ){

    taglist = htmltools::tagList()

    if(var %in% data_ls$numericals){

      taglist[[1]] = f_plot_hist( var, data_ls, col_group, graph_type = 'violin'
                                  , title = title , subtitle = '* P:0.05, ** P:0,005, *** P:0.001' ) %>%
        plotly::ggplotly( tooltip = c('y','fill') )

      taglist[[2]] = htmltools::h1( paste(title, '* P:0.05, ** P:0,005, *** P:0.001' ) )

    }else{

      taglist[[1]]  = f_plot_hist( var, data_ls, col_group, graph_type = 'bar' , y_axis = 'count'
                                   , title = paste(title, 'proportions'), caption = '* P:0.05, ** P:0,005, *** P:0.001' ) %>%
        plotly::ggplotly( tooltip = c('y','fill') )

      taglist[[2]] = f_plot_hist( var, data_ls, col_group, graph_type = 'bar' , y_axis = 'density'
                                  , title = paste(title, 'counts' ), caption = '* P:0.05, ** P:0,005, *** P:0.001'  ) %>%
        plotly::ggplotly( tooltip = c('y','fill') )

      taglist[[3]] =  htmltools::tags$br()
    }

    return( taglist )

  }

  df_comb = df_comb %>%
    mutate( stars = ifelse( p_value <= 0.001, '***'
                    , ifelse(p_value <= 0.005, '**'
                    , ifelse(p_value <= 0.05, '*', 'ns') ) )
            ,title = paste( variable, stars)
            , plot = map2( variable, title, f_plot, col_group, data_ls )
            )

  taglist = htmltools::tagList( df_comb$plot )

  return( taglist )

}

