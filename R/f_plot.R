
#'@import ggplot2
#'@import RColorBrewer
#'@importFrom stringr str_extract_all

#' @title generate a most distinctive color scale
#' @description based on RColorBrewer colours of length 74

#' @return vector with HEX colours
#' @rdname f_plot_col_vector74
#' @export
#'
f_plot_col_vector74 = function(){

  library(RColorBrewer)
  n <- 60
  qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
  col_vector = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))

}

#' @title color code all variables in a data_ls list.
#' @description color coding is stable the same data_ls list gets the same
#'   coding with every function call. Assigns the same colors to the boxcox
#'   transformed and untransformed variant of a variable.
#'@param data_ls data_ls object generated by f_clean_data(), or a named list
#'   list( data = <dataframe>, numericals = < vector with column names of
#'   numerical columns>)
#' @param col_vector character vector denoting Hexcode colors, Default: f_plot_col_vector74()
#' @return tibble
#' \itemize{
#'   \item{variable}{}
#'   \item{color}{HEX code color}
#'   }
#'
#' @examples
#' f_clean_data(mtcars) %>%
#'   f_boxcox() %>%
#'   f_plot_color_code_variables() %>%
#'   print()
#' @seealso \code{\link[stringr]{str_replace_all}}
#' @rdname f_plot_color_code_variables
#' @export
#' @importFrom stringr str_replace_all

f_plot_color_code_variables = function(data_ls
                                       , col_vector = f_plot_col_vector74() ){

  multiple = length( data_ls$all_variables ) / length(col_vector)
  multiple = ceiling(multiple)

  col_vector = rep(col_vector, multiple)

  tib = tibble( variables = data_ls$all_variables
                , color   = col_vector[1:length(data_ls$all_variables)]
                )

  # code boxcox variables with the same colours as their untransformed counterparts
  if( ! is.null(data_ls$boxcox_names) ){

    names_boxcox = data_ls$boxcox_names %>%
      stringr::str_replace_all('_boxcox', '')

    tib_boxcox = tib %>%
      filter( variables %in% names_boxcox ) %>%
      mutate( variables = paste0( variables, '_boxcox') )

    tib = tib %>%
      bind_rows(tib_boxcox)

  }

  return(tib)
}

#'@title Plot Histograms
#'@description Function plots smart histograms for variables in a data_ls list
#'  generated by f_clean_data(). It supports three types of histograms: Bar
#'  histograms, density histograms and violin plots. We can further specify a
#'  categorical variable to group on. The function defaults to a sensible
#'  standard output if key word arguments are not applicable for variable type.
#'  Thus we can easily pipe through long lists of variables and thus generate
#'  histograms for all variables in the input (see examples).
#'@param variable character vector naming the variable to be plotted
#'@param data_ls data_ls object generated by f_clean_data(), or a named list
#'   list( data = <dataframe>, numericals = < vector with column names of
#'   numerical columns>)
#'@param group character vector naming the column to be used as grouping variable, Default: NULL
#'@param graph_type one of c("violin", "bar", "line"), Default: 'violin'
#'@param y_axis one of c("count", "density"), Default: c("count", "density")
#'@param auto_range boolean, Default: T
#'@param n_breaks integer , Default: 30
#'@param x_min double, requires aut_range == F, Default: 0
#'@param x_max double, requires aut_range == F,  Default: 100
#'@return plot object
#'@details DETAILS
#' @examples
#' \dontrun{
#' #'
#' #plot single variable
#' data_ls = f_clean_data(mtcars)
#' f_plot_hist('disp', data_ls)
#' f_plot_hist('disp', data_ls, graph_type = 'violin', group = 'cyl')
#'
#'#plot all variables
#'vars = c(data_ls$categorical, data_ls$numericals) %>%
#'  walk( f_plot_hist, data_ls, group = 'cyl')
#'}
#'@rdname f_plot_hist
#'@export
#'
#'
f_plot_hist = function(variable
                       , data_ls
                       , group = 'None'
                       , graph_type = c('violin','bar','line')
                       , y_axis = c('count','density')
                       , auto_range = T
                       , n_breaks = 30
                       , x_min = 0
                       , x_max = 100 ){

  data          = data_ls$data
  categoricals  = data_ls$categoricals
  all_variables = data_ls$all_variables
  numericals    = data_ls$numericals

  x_min = min
  x_max = max


  if(variable %in% numericals){
    print('variable in numericals')
  }

  if(variable %in% categoricals){
    print('variable in categoricals')
  }

  #y-axis
  if(y_axis == 'density') {
    y_axis = '..density..'
  }  else{
    y_axis = '..count..'
  }

  #group

  if(group == 'None') group = NULL

  #violin plots require a grouping variable, defaults to bar histogram

  #geom_freqpoly
  if( (variable %in% numericals & graph_type == 'line')  ){

    p = data %>%
      ggplot() +
      geom_freqpoly( aes_string(x = variable, y = y_axis, color = group)
                     , bins =  as.numeric(n_breaks))
  }


  #geom_histo
  if( (variable %in% numericals & graph_type == 'bar')
      | (graph_type == 'violin' & is.null(group)) ){

    p = data %>%
      ggplot() +
      geom_histogram( aes_string(x = variable, y = y_axis, fill = group)
                      , bins =  as.numeric(n_breaks), alpha = 0.6
                      , position = 'identity')
  }

  #geom_violin
  if(variable %in% numericals & graph_type == 'violin' & !is.null(group) ){

    medians = data %>%
      #group_by_(as.symbol(group)) %>%
      group_by_(group) %>%
      select( one_of(numericals ) ) %>%
      summarise_all(  median )


    p = data %>%
      ggplot() +
      geom_violin( aes_string(x = group
                              , y = variable
                              , fill = group)
      ) +
      geom_crossbar( data = medians,
                     mapping = aes_string(x = group
                                          , y = variable
                                          , ymin = variable
                                          , ymax = variable) )
  }


  # add x range

  if(variable %in% numericals & auto_range == F & !graph_type == 'violin'){

    p = p +
      xlim( c( as.numeric(x_min), as.numeric(x_max)) )
  }

  # add y range

  if(variable %in% numericals & auto_range == F & graph_type == 'violin'){

    p = p +
      ylim( c( as.numeric(x_min), as.numeric(x_max)) )
  }


  # categoricals ----------------------------------------------------------------------------

  #geom_bar
  if(variable %in% categoricals ){

    if(y_axis == '..density..')   y_axis = '..prop..'

    p = data %>%
      ggplot() +
      geom_bar( aes_string(x = variable, y = y_axis, fill = group, group = group)
                , position = 'dodge') +
      theme( axis.text.x = element_text( angle = 90 ) )


  }

  y_axis_str = stringr::str_extract_all(y_axis
                                        , '[A-Za-z]') %>%
    unlist()%>%
    stringr::str_c(collapse = '')


  return(p)

}


#'@title plot variable distribution over time as reduced overlapping boxplots
#'@description It is difficult to compare two timeerieses when you have more
#'  than one observation per timepoint without reducing all observations to a
#'  single statistical variable such as average or mean. This visualisation
#'  plots the median and the upper and lower 25% percentile instead drawing a
#'  contineuos line between the medians ot the timepoints.
#'@param variable character vector naming the variable to be plotted
#'@param data_ls data_ls object generated by f_clean_data(), or a named list
#'  list( data = <dataframe>, numericals = < vector with column names of
#'  numerical columns>)
#'@param group character vector naming the column to be used as grouping
#'  variable, Default: NULL
#'@param time_variable character vector naming the timevariable to be plotted
#'@param time_variable_as_factor If TRUE will convert time_variable to a factor,
#'  this will equalize the distance between timepoints on the plots and drops
#'  the connective line between timepoints, Default: F
#'@param normalize If TRUE y variable will be divided by x variable, usefull if
#'  y variable represents a cumulated sum, Default: F
#'@param time_unit character vector used as an x-axis lable , Default: 'day'
#'@return plot
#' @examples
#' \dontrun{
#'
#' set.seed(1)
#' data       = dplyr::sample_n( nycflights13::flights, 1000 )
#' data$is_ua = ifelse( data$carrier == 'UA', 'UA', 'other')
#' data$date  = data$year * 10000 + data$month * 100 + data$day
#' data$date  = lubridate::as_date( data$date )
#' data_ls    = f_clean_data( data, replace_neg_values_with_zero = F)
#' f_plot_time( 'arr_delay', 'month', data_ls, group = 'is_ua', time_unit = 'month', time_variable_as_factor = T)
#'
#' #without grouping
#' f_plot_time( 'arr_delay', 'month', data_ls, time_unit = 'month', time_variable_as_factor = F)
#'
#' }
#'
#'@rdname f_plot_time
#'@export
f_plot_time = function(variable
                       , time_variable
                       , data_ls
                       , time_variable_as_factor = F
                       , group = NULL
                       , normalize = F
                       , time_unit = 'day'){

  data       = data_ls$data
  numericals = data_ls$numericals


  time_variable_sym  <- as.name(time_variable)
  variable_sym       <- as.name(variable)


  #make sure variables are in correct format

  if( time_variable_as_factor == T){

    data = data %>%
      mutate( !!time_variable_sym := as.factor(!!time_variable_sym) )

  } else {

    data = data %>%
      mutate( !!time_variable_sym    := as.character(!!time_variable_sym)
               , !!time_variable_sym := as.numeric(!!time_variable_sym) )

  }

  if(!variable %in% numericals){
    stop('variable not in numericals')
  }

  # normalize data if appliquable

  if(normalize == T){
    data = data %>%
      filter( (!!time_variable_sym) != 0) %>%
      mutate( !!variable_sym := (!!variable_sym) / (!!time_variable_sym) )

    y_title = paste('Median of', variable, 'per', time_unit)

  }else{
    y_title = paste('Median of', variable)
  }

  boxplot_sum = data %>%
    select( one_of( c(time_variable, variable, group ) ) ) %>%
    group_by_at( vars( one_of(time_variable, group ) ) ) %>%
    nest() %>%
    mutate( data            = map( data, variable )
            , boxplot       = map( data, boxplot.stats)
            , boxplot_stats = map( boxplot, 'stats')
            , box_min       = map_dbl( boxplot_stats, function(x) x[1] )
            , box_min_box   = map_dbl( boxplot_stats, function(x) x[2] )
            , box_median    = map_dbl( boxplot_stats, function(x) x[3] )
            , box_max_box   = map_dbl( boxplot_stats, function(x) x[4] )
            , box_max       = map_dbl( boxplot_stats, function(x) x[5] )
    ) %>%
    select( - boxplot_stats, - boxplot )

  p = ggplot(boxplot_sum, aes_string( x      = time_variable
                                     , y     = 'box_median'
                                     , color = group )
  )+
    geom_line( size = 1 )+
    geom_crossbar( aes_string( ymin  = 'box_min_box'
                              , ymax = 'box_max_box'
                              , fill = group
                )
                , stat     = 'identity'
                , alpha    = 0.1
                , position = 'identity') +
    geom_errorbar( aes_string( ymin  = 'box_median'
                              , ymax = 'box_median'
                            )
                , size = 1) +
    geom_point( size = 2 ) +
    labs( y = y_title
          , x = time_unit
          , subtitle = 'Boxes denote upper and lower 25% percentile')

  return(p)

}


#' @title genereate a separate html file from a shiny taglist
#' @description html objects generated by plotly or DT can be stored in
#'   htmltools::tagList. It can be printed in a html file to display the objects.
#' @param taglist htmltools::tagList
#' @param output_file file_name of the html file, without .html suffix
#' @param title character vector of html document title, Default: 'Plots'
#' @examples
#' \dontrun{
#' if(interactive()){
#'  #EXAMPLE1
#'  }
#' }
#' @rdname f_plot_taglist_2_html
#' @export
#' @importFrom readr read_file write_file
#' @importFrom rmarkdown render
#' @importFrom stringr str_replace
#'
f_plot_taglist_2_html = function(taglist, output_file, title = 'Plots'){

  file_name_template = 'taglist_2_html_template.Rmd'

  path_template = file.path( system.file(package = 'oetteR')
                             , 'templates'
                             , file_name_template)

  txt = readr::read_file(path_template) %>%
    stringr::str_replace('template', title)

  readr::write_file( txt, file_name_template)

  rmarkdown::render( file_name_template
                     , output_file = paste0( output_file, '.html')
                     , params      = list(taglist = taglist)
                     )

  file.remove(file_name_template)

  return( file.path( getwd(), output_file) )

}



#' @title plot revenues cost and profit development over time as an area chart.
#' @description the function can graphically devide the chart into two periods
#'   e.g. past and future.
#' @param data datafram
#' @param col_revenue character vector denoting revenue column
#' @param col_cost character vector denoting cost column
#' @param col_time character vector denoting time column
#' @param now integer denoting a time which should be regarded as the
#'   breakpoint, Default: max(data[, col_time])
#' @param unit_time character vector, will label y-axis, Default: 'years'
#' @param unit_value character vector, will label x-axis, Default: 'CHF'
#' @param title character vector, will be title label, Default: ''
#' @param alpha_past double between 0 and 1 will determine alpha value for fill
#'   under the curve before the breakpoint, Default: 1
#' @param alpha_future double between 0 and 1 will determine alpha value for fill
#'   under the curve after the breakpoint, Default: 0.5
#' @return plot (is not plotly compatibel)
#' @details not plotly compatibel
#' @examples
#' data = tibble( time     = c(0,1,2,3,4,5,6,7,8,9,10)
#'               , revenue = - time^2 + time * 12
#'               , cost    = revenue * 0.4 * -1
#'              )
#'
#' print( f_plot_profit_lines( data, 'revenue', 'cost', 'time') )
#' print( f_plot_profit_lines( data, 'revenue', 'cost', 'time', now = 5) )
#'
#' @rdname f_plot_profit_lines
#' @export
f_plot_profit_lines = function( data
                                , col_revenue
                                , col_cost
                                , col_time
                                , now = max(data[,col_time])
                                , unit_time = 'years'
                                , unit_value = 'CHF'
                                , title = ''
                                , alpha_past = 1
                                , alpha_future = 0.5
                                ){


  #calculate profit
  data = tibble( time      = data[[col_time ]]
                 , revenue = data[[col_revenue]]
                 , cost    = data[[col_cost]]
                 , profit  = revenue + cost
                )

  data = data %>%
    gather(key = 'key', value = 'value', - time )

  revenues = data %>%
    filter( key == 'revenue')

  cost = data %>%
    filter( key == 'cost')

  profit = data %>%
    filter( key == 'profit')

  # plot init

  p = ggplot()

  #past-----------------------------------------

  p = p +
    geom_area( data = revenues
               , mapping = aes( x = ifelse(time <= now,time, min(data$time)-1 )
                                , y = value
                                )
               , alpha = alpha_past
               , fill = 'springgreen3'
               , position = 'identity'
               ) +
    geom_area( data = cost
               , mapping = aes( x = ifelse(time <= now,time, min(data$time)-1 )
                                , y = value
                                )
               , alpha = alpha_past
               , fill = 'firebrick2'
               , position = 'identity'
              ) +
    geom_area( data = profit
               , mapping = aes( x = ifelse(time <= now,time, min(data$time)-1 )
                                , y = value
                                )
               , alpha = alpha_past
               , fill = 'royalblue2'
               , position = 'identity'
               )

  #future---------------------------------------

  p = p +
    geom_area( data = revenues
               , mapping = aes( x = ifelse(time >= now, time, now)
                                , y = value
                                )
               , alpha = alpha_future
               , fill = 'springgreen3'
               , position = 'identity'
               , show.legend = T
              ) +
    geom_area( data = cost
               , mapping = aes( x = ifelse(time >= now, time, now)
                                , y = value
               )
               , alpha = alpha_future
               , fill = 'firebrick2'
               , position = 'identity'
               ) +
    geom_area( data = profit
               , mapping = aes( x = ifelse(time >= now, time, now)
                                , y = value
               )
               , alpha = alpha_future
               , fill = 'royalblue2'
               , position = 'identity'
               )

  # points---------------------------------------

  p = p +
    geom_point( data = data
               , mapping = aes( x = time
                                , y = value
                                , color = key
                                )
               , size  = 4
               )

  # lines---------------------------------------

  p = p +
    geom_line( data = revenues
                , mapping = aes( x = time
                                 , y = value
                )
                , color = 'springgreen4'
                , size  = 2
                #, linetype = 3
                ) +
    geom_line( data = cost
                , mapping = aes( x = time
                                 , y = value
                )
                , color = 'firebrick3'
                , size  = 2
                #, linetype = 2
               ) +
    geom_line( data = profit
                , mapping = aes( x = time
                                 , y = value
                )
                , color = 'royalblue3'
                , size  = 2
                #, linetype = 2
                )

  # theme--------------------------------------

  p = p +
    theme_minimal() +
    theme( legend.position = 'bottom') +
    xlim( c( min(data$time) , max(data$time) ) )

  # scale--------------------------------------

  p = p +
    scale_color_manual( values = c('firebrick3', 'royalblue3', 'springgreen4')
                        , breaks = c('revenue', 'profit', 'cost') ) +
    #fill = NA removes filled boxes around the points
    guides( color = guide_legend(override.aes = list(size = 5, fill = NA) ) )

  #labels--------------------------------------

  p = p +
    labs( title = title
          , x   = unit_time
          , y   = c( unit_value )
          , color = ''
          )

}

