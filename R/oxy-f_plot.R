

#' @title FUNCTION_TITLE
#' @description FUNCTION_DESCRIPTION

#' @return OUTPUT_DESCRIPTION
#' @details DETAILS
#' @examples
#' \dontrun{
#' if(interactive()){
#'  #EXAMPLE1
#'  }
#' }
#' @rdname f_get_col_vector60
#' @export
f_get_col_vector60 = function(){

  library(RColorBrewer)
  n <- 60
  qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
  col_vector = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))

}


#'@title Plot Histograms
#'@description Function plots smart histograms for variables in a data_ls list
#'  generated by f_clean_data(). It supports three types of histograms: Bar
#'  histograms, density histograms and violin plots. We can further specify a
#'  categorical variable to group on. The function defaults to a sensible
#'  standard output if key word arguments are not applicable for variable type.
#'  Thus we can easily pipe through long lists of variables and thus generate
#'  histograms for all variables in the input (see examples).
#'@param variable PARAM_DESCRIPTION
#'@param data_ls PARAM_DESCRIPTION
#'@param group PARAM_DESCRIPTION, Default: NULL
#'@param graph_type PARAM_DESCRIPTION, Default: c("violin", "bar", "line")
#'@param y_axis PARAM_DESCRIPTION, Default: c("count", "density")
#'@param auto_range PARAM_DESCRIPTION, Default: T
#'@param n_breaks PARAM_DESCRIPTION, Default: 30
#'@param x_min PARAM_DESCRIPTION, Default: 0
#'@param x_max PARAM_DESCRIPTION, Default: 100
#'@return OUTPUT_DESCRIPTION
#'@details DETAILS
#' @examples
#' \dontrun{#'
#' #plot single variable
#' data_ls = f_clean_data(mtcars)
#' f_plot_hist('disp', data_ls)
#' f_plot_hist('disp', data_ls, graph_type = 'violin', group = 'cyl')
#'
#'#plot all variables
#'
#'vars = c(data_ls$categorical, data_ls$numericals) %>%
#'  walk( f_plot_hist, data_ls, group = 'cyl')
#'}
#'@seealso \code{\link[stringr]{str_extract_all}},\code{\link[stringr]{str_c}}
#'@rdname f_plot_hist
#'@export
#'@importFrom stringr str_extract_all str_c
#'
#'
f_plot_hist = function(variable
                       , data_ls
                       , group = 'None'
                       , graph_type = c('violin','bar','line')
                       , y_axis = c('count','density')
                       , auto_range = T
                       , n_breaks = 30
                       , x_min = 0
                       , x_max = 100 ){

  data          = data_ls$data
  categoricals  = data_ls$categoricals
  all_variables = data_ls$all_variables
  numericals    = data_ls$numericals

  x_min = min
  x_max = max


  if(variable %in% numericals){
    print('variable in numericals')
  }

  if(variable %in% categoricals){
    print('variable in categoricals')
  }

  #y-axis
  if(y_axis == 'density') {
    y_axis = '..density..'
  }  else{
    y_axis = '..count..'
  }

  #group

  if(group == 'None') group = NULL

  #violin plots require a grouping variable, defaults to bar histogram

  #geom_freqpoly
  if( (variable %in% numericals & graph_type == 'line')  ){

    p = data %>%
      ggplot() +
      geom_freqpoly( aes_string(x = variable, y = y_axis, color = group)
                     , bins =  as.numeric(n_breaks))
  }


  #geom_histo
  if( (variable %in% numericals & graph_type == 'bar')
      | (graph_type == 'violin' & is.null(group)) ){

    p = data %>%
      ggplot() +
      geom_histogram( aes_string(x = variable, y = y_axis, fill = group)
                      , bins =  as.numeric(n_breaks), alpha = 0.6
                      , position = 'identity')
  }

  #geom_violin
  if(variable %in% numericals & graph_type == 'violin' & !is.null(group) ){

    medians = data %>%
      #group_by_(as.symbol(group)) %>%
      group_by_(group) %>%
      select( one_of(numericals ) ) %>%
      summarise_all(  median )


    p = data %>%
      ggplot() +
      geom_violin( aes_string(x = group
                              , y = variable
                              , fill = group)
      ) +
      geom_crossbar( data = medians,
                     mapping = aes_string(x = group
                                          , y = variable
                                          , ymin = variable
                                          , ymax = variable) )
  }


  # add x range

  if(variable %in% numericals & auto_range == F & !graph_type == 'violin'){

    p = p +
      xlim( c( as.numeric(x_min), as.numeric(x_max)) )
  }

  # add y range

  if(variable %in% numericals & auto_range == F & graph_type == 'violin'){

    p = p +
      ylim( c( as.numeric(x_min), as.numeric(x_max)) )
  }


  # categoricals ----------------------------------------------------------------------------

  #geom_bar
  if(variable %in% categoricals ){

    if(y_axis == '..density..')   y_axis = '..prop..'

    p = data %>%
      ggplot() +
      geom_bar( aes_string(x = variable, y = y_axis, fill = group, group = group)
                , position = 'dodge') +
      theme( axis.text.x = element_text( angle = 90 ) )


  }

  y_axis_str = stringr::str_extract_all(y_axis
                                        , '[A-Za-z]') %>%
    unlist()%>%
    stringr::str_c(collapse = '')



  print(p)

}


#' @title FUNCTION_TITLE
#' @description FUNCTION_DESCRIPTION
#' @param variable PARAM_DESCRIPTION
#' @param time_variable PARAM_DESCRIPTION
#' @param data_ls PARAM_DESCRIPTION
#' @param .f PARAM_DESCRIPTION, Default: mean
#' @param time_variable_as_factor PARAM_DESCRIPTION, Default: F
#' @param group PARAM_DESCRIPTION, Default: NULL
#' @param normalize PARAM_DESCRIPTION, Default: F
#' @param time_unit PARAM_DESCRIPTION, Default: 'day'
#' @return OUTPUT_DESCRIPTION
#' @details DETAILS
#' @examples
#' \dontrun{
#' if(interactive()){
#'  #EXAMPLE1
#'  }
#' }
#' @rdname f_plot_time
#' @export
f_plot_time = function(variable
                       , time_variable
                       , data_ls
                       , .f = mean
                       , time_variable_as_factor = F
                       , group = NULL
                       , normalize = F
                       , time_unit = 'day'){

  data       = data_ls$data
  numericals = data_ls$numericals


  time_variable_sym  <- as.name(time_variable)
  variable_sym       <- as.name(variable)
  group_sym          <- as.name(group)

  #make sure variables are in correct format

  if( time_variable_as_factor == T){

    data = data %>%
      mutate( !!time_variable_sym := as.factor(!!time_variable_sym) )

  } else {

    data = data %>%
      mutate( !!time_variable_sym    := as.character(!!time_variable_sym)
               , !!time_variable_sym := as.numeric(!!time_variable_sym) )

  }

  if(!variable %in% numericals){
    stop('variable not in numericals')
  }

  # normalize data if appliquable

  if(normalize == T){
    data = data %>%
      filter( (!!time_variable_sym) != 0) %>%
      mutate( !!variable_sym := (!!variable_sym) / (!!time_variable_sym) )

    y_title = paste('Median of', variable, 'per', time_unit)

  }else{
    y_title = paste('Median of', variable)
  }

  boxplot_sum = data %>%
    select( !!time_variable_sym, !!variable_sym, !!group_sym ) %>%
    group_by( !!time_variable_sym, !!group_sym ) %>%
    nest() %>%
    arrange( !!time_variable_sym, !!group_sym)%>%
    mutate( data            = map( data, variable )
            , boxplot       = map( data, boxplot.stats)
            , boxplot_stats = map( boxplot, 'stats')
            , box_min       = map_dbl( boxplot_stats, function(x) x[1] )
            , box_min_box   = map_dbl( boxplot_stats, function(x) x[2] )
            , box_median    = map_dbl( boxplot_stats, function(x) x[3] )
            , box_max_box   = map_dbl( boxplot_stats, function(x) x[4] )
            , box_max       = map_dbl( boxplot_stats, function(x) x[5] )
    ) %>%
    select( - boxplot_stats, - boxplot )

  p = ggplot(boxplot_sum, aes_string( x      = time_variable
                                     , y     = 'box_median'
                                     , color = group )
  )+
    geom_line( size = 1 )+
    geom_crossbar( aes_string( ymin  = 'box_min_box'
                              , ymax = 'box_max_box'
                              , fill = group
                )
                , stat     = 'identity'
                , alpha    = 0.1
                , position = 'identity') +
    geom_errorbar( aes_string( ymin  = 'box_median'
                              , ymax = 'box_median'
                            )
                , size = 1) +
    geom_point( size = 2 ) +
    labs( y = y_title
          , x = time_unit
          , subtitle = 'Boxes denote upper and lower 25% percentile')

  print(p)

}






