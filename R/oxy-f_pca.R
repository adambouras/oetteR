



#'@title calculate principle components for a dataset
#'@description This function is an extended wrapper for prcomp(). I takes a
#'  data_ls object created by f_clean_data and calculates the contribution of
#'  each variable to each principle component in percent.
#'@param data_ls data_ls object generated by f_clean_data(), or a named list
#'  list( data = <dataframe>, numericals = < vector with column names of
#'  numerical columns>)
#'@param use_boxcox_tansformed_vars boolean, Default: T
#'@param center boolean, Default: T
#'@param scale boolean, Default: T
#'@return a list with the original data complemented with the principle
#'  component vector data of each observation and an object returned by prcomp()
#'  supplemented with some extra features \item{data}{dataframe} \item{pca}{pca
#'  object created by prcomp()}
#'
#'  \strong{added features of pca}: \item{cos2}{The squared rotation vectors.A
#'  value between 0 and 1 denotes the amount of contribution of a variable to a
#'  specific principle component} \item{vae}{percent variance explained}
#'  \item{contrib_abs_perc}{The absolute contribution of one variable to the
#'  variance explained by one principle component in percent. The total
#'  contibution adds up to the total contibution of the principle componaent in
#'  percent. } \item{contrib_abs_perc_reduced}{as above but variables
#'  contibuting less than 2.5 percent are grouped}
#'  \item{threshold_vae_for_pc_perc}{principle components that explain less
#'  percent variance than this threshold are dropped}
#'@details
#'\href{http://www.sthda.com/english/wiki/principal-component-analysis-how-to-reveal-the-most-important-variables-in-your-data-r-software-and-data-mining}{Blog
#'post explaining how to calculate contributions}
#' @examples
#'pca_ls = f_clean_data(mtcars) %>%
#' f_boxcox() %>%
#' f_pca()
#'
#'@rdname f_pca
#'@export
#'@seealso \code{\link[stats]{prcomp}}
f_pca = function( data_ls
                  , center = T
                  , scale = T
                  , use_boxcox_tansformed_vars = T
                  , include_ordered_categoricals = T
                  , threshold_vae_for_pc_perc = 2.5
                  ){


   data                 = data_ls$data
   boxcox               = data_ls$boxcox_data
   categoricals         = data_ls$categoricals
   categoricals_ordered = data_ls$categoricals_ordered
   all_variables        = data_ls$all_variables
   numericals           = data_ls$numericals

   if(is_empty(numericals) |
      ( is_empty(boxcox) & use_boxcox_tansformed_vars == T ) ){
     stop('Either numerical or boxcox transformed variables missing')
   }

   if(use_boxcox_tansformed_vars) {

     data = boxcox

   } else{

     data = data %>%
       select( one_of(numericals) )
   }

   if( include_ordered_categoricals == T ){

     data = data %>%
       bind_cols( data_ls$data[, categoricals_ordered] ) %>%
       mutate_all( as.character ) %>%
       mutate_all( as.numeric )

   }

   pca = prcomp(x        = data
                , scale. = scale
                , center = center) %>%
     map( f_manip_matrix_2_tibble )

   pca$cos2 = pca$rotation %>%
     mutate_if( is.numeric, function(y) y^2)

   pca$contrib = pca$cos2 %>%
     mutate_if(is.numeric, function(y) y/ sum(y) *100)

   pca$vae = as_tibble (t( pca$sdev / sum(pca$sdev) *100 ) ) %>%
     mutate( row_names = 'vae' ) %>%
     select( row_names, everything() )

   colnames(pca$vae) = colnames(pca$contrib)

   # i cant find a solution for this using purr

   contrib_mat = pca$contrib %>%
     select(2:ncol(.)) %>%
     as.matrix()

   vae_mat = pca$vae %>%
     select(2:ncol(.)) %>%
     as.matrix()

   pca$contrib_abs_perc = t( apply( contrib_mat/100, 1, function(x,y) vae_mat * x ) ) %>%
     as_tibble() %>%
     mutate(row_names = pca$contrib$row_names ) %>%
     select(row_names, everything() )

   names( pca$contrib_abs_perc ) = names(pca$vae)

   pca$contrib_abs_perc = pca$contrib_abs_perc %>%
     gather(key = 'PC', value = 'value', everything(), -row_names)

   #group variables with less than 2.5% contribution
   pca$contrib_abs_perc_reduced = pca$contrib_abs_perc  %>%
     mutate(row_names = ifelse(value < 2.5
                         , ' sum contrib < 2.5%'
                         , row_names)) %>%
     group_by( row_names, PC) %>%
     summarise( value = sum(value) )


   # filter principle components that explain less than
   # threshold_vae_for_pc_perc of the variance

   bool = pca$vae %>%
     select_if( is.numeric) %>%
     summarise_all( function(x) x > threshold_vae_for_pc_perc) %>%
     as.matrix() %>%
     as.vector()

   pca$x                        = pca$x[,bool]

   pca$contrib_abs_perc         = pca$contrib_abs_perc %>%
     filter(PC %in% colnames(pca$x))

   pca$contrib_abs_perc_reduced = pca$contrib_abs_perc_reduced %>%
     filter(PC %in% colnames(pca$x))

   data = data_ls$data %>%
     cbind(pca$x)



  return(list(data = data, pca = pca) )

}


#' @title plot principle components as a dot plot
#' @param pca_ls list created by f_pca()
#' @param x_axis character vector, Default: 'PC1'
#' @param y_axis character vector, Default: 'PC2'
#' @param group character vector denoting the grouping variable, determines dot colour, Default: NULL
#' @return ggplot
#' @examples
#' \dontrun{
#'pca_ls = f_clean_data(mtcars) %>%
#' f_boxcox() %>%
#' f_pca() %>%
#' f_pca_plot_components()%>%
#' print()
#' }
#' @rdname f_pca_plot_components
#' @export
f_pca_plot_components = function(pca_ls
                                 , x_axis = 'PC1'
                                 , y_axis = 'PC2'
                                 , group = NULL
                                 , print_tables = T){

  data = pca_ls$data
  pca  = pca_ls$pca


  p = ggplot(data) +
    geom_point( aes_string(x = x_axis, y = y_axis, color = group)
                ,alpha=0.4 ) +
    labs(title = 'Principle Components')

  #convert rotation matrix to tibble and join contribution in percent
  tib = pca$rotation %>%
    gather( key = 'PC', value = 'rotation',  - row_names) %>%
    left_join( pca$contrib_abs_perc) %>%
    rename( abs_contrib_perc = value )



  #print contrib x_axis
  dt_x = tib %>%
    filter( PC == x_axis) %>%
    arrange( desc(abs_contrib_perc) ) %>%
    select(row_names, abs_contrib_perc, rotation) %>%
    DT::datatable( caption = 'x-axis')


  #print contrib y_axis
  dt_y = tib %>%
    filter( PC == y_axis) %>%
    arrange( desc(abs_contrib_perc) ) %>%
    select(row_names, abs_contrib_perc, rotation) %>%
    DT::datatable()

  tagl = htmltools::tagList( list( p, dt_x, dt_y) )

}

#' @title FUNCTION_TITLE
#' @description FUNCTION_DESCRIPTION
#' @param pca_ls PARAM_DESCRIPTION
#' @return OUTPUT_DESCRIPTION
#' @details DETAILS
#' @examples
#' \dontrun{
#' if(interactive()){
#'  #EXAMPLE1
#'  }
#' }
#' @rdname f_pca_get_plot_variance_explained
#' @export
f_pca_get_plot_variance_explained = function(pca_ls){

  pca = pca_ls$pca

  vae = tibble( value = pca$sdev
                , pca_n = str_c('pca', 1:length(pca$sdev))
  )

  p =   ggplot(pca$contrib_abs_perc_reduced) +
    geom_bar(aes(x = fct_reorder(var, value, sum, .desc = T )
                 , y = value, fill = key)
             , stat = 'identity'
             , position='stack') +
    scale_fill_brewer(palette = 'Paired') +
    labs( title = 'Variance Explained')

  return(p)

}

