



#'@title calculate principle components for a dataset
#'@description This function is an extenstion to prcomp(). I takes a data_ls
#'  object created by f_clean_data and calculates the contribution of each
#'  variable to each principle component in percent.
#'@param data_ls data_ls object generated by f_clean_data(), or a named list
#'  list( data = <dataframe>, numericals = < vector with column names of
#'  numerical columns>)
#'@param use_boxcox_tansformed_vars boolean, Default: T
#'@param center boolean, Default: T
#'@param scale boolean, Default: T
#'@return a list with the original data complemented with the principle
#'  component vector data of each observation and an object returned by prcomp()
#'  supplemented with some extra features
#'  \item{data}{dataframe}
#'  \item{pca}{pca object created by prcomp()}
#'
#'\strong{added features of pca}:
#'  \item{cos2}{The squared rotation
#'  vectors.A value between 0 and 1 denotes the amount of contribution of a
#'  variable to a specific principle component}
#'  \item{vae}{percent variance
#'  explained}
#'  \item{contrib_abs_perc}{The absolute contribution of one variable
#'  to the variance explained by one principle component in percent. The total
#'  contibution adds up to the total contibution of the principle componaent in
#'  percent. }
#'  \item{contrib_abs_perc_reduced}{as above but variables
#'  contibuting less than 2.5 percent are grouped}
#'@details
#'  \href{http://www.sthda.com/english/wiki/principal-component-analysis-how-to-reveal-the-most-important-variables-in-your-data-r-software-and-data-mining}{Blog
#'  post explaining how to calculate contributions}
#' @examples
#'pca_ls = f_clean_data(mtcars) %>%
#' f_boxcox() %>%
#' f_pca()
#'
#'@rdname f_pca
#'@export
#'@seealso \code{\link[stats]{prcomp}}
f_pca = function( data_ls
                  , use_boxcox_tansformed_vars = T
                  , center = T
                  , scale = T
                  ){


   data          = data_ls$data
   boxcox        = data_ls$boxcox_data
   categoricals  = data_ls$categoricals
   all_variables = data_ls$all_variables
   numericals    = data_ls$numericals

   if(is_empty(numericals) |
      ( is_empty(boxcox) & use_boxcox_tansformed_vars == T ) ){
     stop('Either numerical or boxcox transformed variables missing')
   }

   if(use_boxcox_tansformed_vars) {

     data = boxcox

   } else{

     data = data %>%
       select( one_of(numericals) )
   }

   pca = prcomp(x        = data
                , scale. = scale
                , center = center)

   pca$cos2 = pca$rotation^2

   pca$contrib = lmap( as_tibble(pca$cos2 ), function(y) y/ sum(y) *100 )
   row.names(pca$contrib) = row.names(pca$cos2)

   pca$vae = as_tibble (t( pca$sdev / sum(pca$sdev) *100 ) )
   colnames(pca$vae) = colnames(pca$contrib)

   pca$contrib_abs_perc = t( t( apply( pca$contrib/100, 1, function(x,y) x*pca$vae ) ) )
   pca$contrib_abs_perc = unnest( as.data.frame( pca$contrib_abs_perc) )
   row.names(pca$contrib_abs_perc) = row.names(pca$contrib)

   pca$contrib_abs_perc = as.data.frame( t(pca$contrib_abs_perc) )
   pca$contrib_abs_perc$var = row.names(pca$contrib_abs_perc)

   pca$contrib_abs_perc = pca$contrib_abs_perc %>%
     gather(key = 'key', value = 'value', everything(), -var)

   #group variables with less than 2.5% contribution
   pca$contrib_abs_perc_reduced = pca$contrib_abs_perc  %>%
     mutate(key = ifelse(value < 2.5
                         , ' sum contrib < 2.5%'
                         , key)) %>%
     group_by( var, key) %>%
     summarise( value = sum(value) )


   # filter principle components that explain less than
   # 2.5% of the variance

   pca$x                        = pca$x[, pca$vae > 2.5]

   pca$contrib_abs_perc         = pca$contrib_abs_perc %>%
     filter(var %in% colnames(pca$x))

   pca$contrib_abs_perc_reduced = pca$contrib_abs_perc_reduced %>%
     filter(var %in% colnames(pca$x))

   data = data %>%
     cbind(pca$x)



  return(list(data = data, pca = pca) )

}


#' @title plot principle components as a dot plot
#' @param pca_ls list created by f_pca()
#' @param x_axis character vector, Default: 'PC1'
#' @param y_axis character vector, Default: 'PC2'
#' @param group character vector denoting the grouping variable, determines dot colour, Default: NULL
#' @return ggplot
#' @examples
#' \dontrun{
#' data_ls = f_clean_data(mtcars)
#' pca_ls = f_pca(data_ls)
#' f_pca_plot_components(pca_ls)
#' }
#' @rdname f_pca_plot_components
#' @export
f_pca_plot_components = function(pca_ls
                                 , x_axis = 'PC1'
                                 , y_axis = 'PC2'
                                 , group = NULL){

  data = pca_ls$data
  pca  = pca_ls$pca


  p = ggplot(data) +
    geom_point( aes_string(x = x_axis, y = y_axis, color = group)
                ,alpha=0.4 ) +
    labs(title = 'Principle Components')

  #convert rotation matrix to tibble and join contribution in percent
  tib = pca$rotation %>%
    as_tibble() %>%
    mutate( var = row.names( pca$rotation ) ) %>%
    gather( key = 'key', value = 'rotation',  - var) %>%
    left_join( pca$contrib_abs_perc, by = c( 'key' = 'var', 'var' = 'key' )) %>%
    rename( abs_contrib_perc = value )



  #print contrib x_axis
  tib %>%
    filter( key == x_axis) %>%
    arrange( desc(abs_contrib_perc) ) %>%
    select(var, abs_contrib_perc, rotation) %>%
    head(20) %>%
    print()


  #print contrib y_axis
  tib %>%
    filter( key == y_axis) %>%
    arrange( desc(abs_contrib_perc) ) %>%
    select(var, abs_contrib_perc, rotation) %>%
    head(20) %>%
    print()


  return(p)

}

#' @title FUNCTION_TITLE
#' @description FUNCTION_DESCRIPTION
#' @param pca_ls PARAM_DESCRIPTION
#' @return OUTPUT_DESCRIPTION
#' @details DETAILS
#' @examples
#' \dontrun{
#' if(interactive()){
#'  #EXAMPLE1
#'  }
#' }
#' @rdname f_pca_get_plot_variance_explained
#' @export
f_pca_get_plot_variance_explained = function(pca_ls){

  pca = pca_ls$pca

  vae = tibble( value = pca$sdev
                , pca_n = str_c('pca', 1:length(pca$sdev))
  )

  p =   ggplot(pca$contrib_abs_perc_reduced) +
    geom_bar(aes(x = fct_reorder(var, value, sum, .desc = T )
                 , y = value, fill = key)
             , stat = 'identity'
             , position='stack') +
    scale_fill_brewer(palette = 'Paired') +
    labs( title = 'Variance Explained')

  return(p)

}
