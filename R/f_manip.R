
#'@import tibble
#'@import tidyr

#' @title converts matrices to tibble, preserving row.names
#' @description row.names are added as row_names column as the first column of
#'   the tibble. Function does not fail when object cannot be converted to
#'   tibble thus can be used to map over lists with various variable types such
#'   as modells and objects.
#' @param x any variable
#' @return a tibble or if the input variable is neither matrix dataframe or
#'   tibble the original input object.
#' @examples
#'
#' mat = as.matrix(mtcars)
#' head( mat, 10)
#' f_manip_matrix_2_tibble( mat )
#'
#' # convert all matrices from a list
#' pca = prcomp( mtcars ) %>%
#'  map( f_manip_matrix_2_tibble )
#' pca
#'
#' @rdname f_manip_matrix_2_tibble
#' @export
f_manip_matrix_2_tibble = function(x){

  if( ! ( is.matrix(x) | is.data.frame(x) ) ){
    warning('argument is not a matrix, returning input object')
    return(x)
  }

  tib = as_tibble(x)

  if( is.character( row.names(x) ) & ! is.tibble(x) ){

    row_names =  row.names(x)

    tib = tib %>%
      mutate( row_names = row_names) %>%
      select( row_names, everything() )
  }

  return(tib)
}

#'@title transpose a tibble
#'@description transpose a tibble, values in first column will become column
#'  titles. Row names will be converted to first columns
#'@param tib tibble
#'@return tibble
#' @examples
#'
#' tib = mtcars %>%
#'   as_tibble() %>%
#'   f_manip_transpose_tibble()
#'tib
#'@rdname f_manip_transpose_tibble
#'@export
f_manip_transpose_tibble = function(tib){

  if(  ! ( is.matrix(tib) | is.data.frame(tib) | is.tibble(tib) ) ){
    stop('input not transposable')
  }

  tib = tib %>%
    f_manip_matrix_2_tibble() %>%
    gather( key = 'key', value = 'value', 2:ncol(.) ) %>%
    spread( key = 1, value = value ) %>%
    rename( row_names = key ) %>%
    arrange( row_names )
}

#' @title takes a data_ls list created by f_clean_data() and returns a list with
#'   all medians for numerical and most common level for categorical variables.
#' @param data_ls data_ls object generated by f_clean_data(), or a named list
#'   list( data = <dataframe>, numericals = < vector with column names of
#'   numerical columns>)
#' @return list\describe{
#'   \item({data}{summarized data as dataframe})
#'   \item({data_boxcox}{summarized boxcox data as dataframe})
#' }
#' @examples
#' summarized_ls = f_clean_data(mtcars) %>%
#'   f_boxcox() %>%
#'   f_manip_summarize_2_median_and_most_common_factor()
#'
#' summarized_ls$data
#' summarized_ls$boxcox_data
#' @rdname f_manip_summarize_2_median_and_most_common_factor
#' @export
f_manip_summarize_2_median_and_most_common_factor = function(data_ls){

  df_numericals = data_ls$data %>%
    select( one_of(data_ls$numericals) ) %>%
    select_if( is.numeric ) %>%
    summarize_all( median )

  df_categoricals = data_ls$data %>%
    select( one_of(data_ls$categoricals) ) %>%
    select_if( is.factor ) %>%
    summarize_all( f_manip_get_most_common_level )

  data = df_numericals %>%
    bind_cols(df_categoricals) %>%
    select( one_of( names(data_ls$data) ) )

  if( 'boxcox_data' %in% names(data_ls) ){

  df_boxcox = data_ls$boxcox_data %>%
    select( one_of(data_ls$boxcox_names) ) %>%
    select_if( is.numeric ) %>%
    summarize_all( median )

  return( list( data = data
                , boxcox_data = df_boxcox) )

  }else{
    return( list( data = data ) )
  }


}

#' @title get most common level from vector
#' @param x factor vector
#' @return character vector
#' @examples
#' data_ls = f_clean_data(mtcars)
#' f_manip_get_most_common_level( data_ls$data$cyl)
#' @seealso
#'  \code{\link[broom]{tidy}}
#' @rdname f_manip_get_most_common_level
#' @export
#' @importFrom broom tidy
f_manip_get_most_common_level = function(x){

  if( ! is.factor(x) ){
    stop( 'f_manip_get_most_common_level called on none factor vector' )
  }

  level = broom::tidy( summary(x) ) %>%
    arrange( desc(x) ) %>%
    .$names %>%
    head(1)

  x = x[x == level] %>%
    head(1)

  return(x)

}

#' @title get variables from formula
#' @param formula formula
#' @return character vector
#' @examples
#' f = foo~bar1 + bar2
#'
#' vars = f_manip_get_variables_from_formula(f)
#' response_var = f_manip_get_response_variable_from_formula(f)
#'
#' @seealso
#'  \code{\link{f_manip_get_response_variable_from_formula}}
#' @rdname f_manip_get_variables_from_formula
#' @export
#' @importFrom stringr str_split
f_manip_get_variables_from_formula = function( formula ) {

  if( ! inherits(formula, 'formula') ){
    stop('f_manip_get_variables_from_formula called with non formula object')
  }

  vars = formula %>%
    as.character() %>%
    .[[3]] %>%
    stringr::str_split( ' \\+ ') %>%
    unlist() %>%
    stringr::str_trim() %>% ## for long formulas as.character
    unlist()                ## will add some whitespace to some variables

  if( vars[1] == '.'){
    stop('cannot extract variables from formula if formula was constructed with "~." ')
  }

  return(vars)

}

#' @title get response variable from formula
#' @param formula formula
#' @return character vector
#' @seealso
#'  \code{\link{f_manip_get_variables_from_formula}}
#' @rdname f_manip_get_response_variable_from_formula
#' @export
#' @importFrom stringr str_split
f_manip_get_response_variable_from_formula = function( formula ) {

  if( ! inherits(formula, 'formula') ){
    stop('f_manip_get_response_variable_from_formula called with non formula object')
  }

  var = formula %>%
    as.character() %>%
    .[[2]]

  return(var)
}

#' @title converts factor to numeric preserving numeric levels and order in character levels
#' @param vec vector
#' @return vector
#' @examples
#' fac_num = factor( c(1,3,8) )
#' fac_chr = factor( c('foo','bar') )
#' fac_chr_ordered = factor( c('a','b','c'), ordered = T )
#'
#' f_manip_factor_2_numeric( fac_num )
#' f_manip_factor_2_numeric( fac_chr )
#' f_manip_factor_2_numeric( fac_chr_ordered )
#' @seealso
#'  \code{\link[stringr]{str_detect}}
#' @rdname f_manip_factor_2_numeric
#' @export
#' @importFrom stringr str_detect
f_manip_factor_2_numeric = function(vec){

  bool = as.character(vec) %>%
    stringr::str_detect('^\\d+$' ) %>%
    all()

  if( bool ){

    vec = vec %>%
      as.character %>%
      as.numeric()

  } else{
    vec = as.numeric(vec)
  }

  return(vec)
}

#' @title bring vector to positice range
#' @description if min < 0, add abs(min) to all values
#' @param vec numeric vector
#' @return vector
#' @examples
#' vec = c( -2,0,2,4,6)
#' vec = f_manip_bring_to_pos_range( vec )
#' vec
#' @rdname f_manip_bring_to_pos_range
#' @export
f_manip_bring_to_pos_range = function(vec){

  if( min(vec)< 0) vec = vec + abs(min(vec))
  return(vec)
}

#' @title append object to list
#' @description convenience function to replace  l[[length(l)+1]] = x
#' @param l list
#' @param x object
#' @return list
#' @examples
#' l = list('a', 'b')
#' l = f_manip_append_2_list(l, 'c')
#' str(l)
#' @rdname f_manip_append_2_list
#' @export
f_manip_append_2_list = function(l, x){

  len = length(l)
  l[[len+1]] = x

  return(l)

}
